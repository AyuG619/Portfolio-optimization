# -*- coding: utf-8 -*-
"""P2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X_YHMDTsy7gU75nA8IynguSb8hDS3NjI
"""

pip install langchain openai pandas numpy scikit-learn yfinance langchain_community matplotlib

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf

import yfinance as yf
import pandas as pd

def get_tickers_interactive():
    print("Enter stock tickers (e.g., AAPL MSFT CVX):")
    user_input = input().strip().upper()
    return user_input.split()

# Get tickers
clean_tickers = get_tickers_interactive()

# Download data
data = yf.download(
    tickers=clean_tickers,
    period="1y",
    interval="1d",
    group_by='ticker',
    auto_adjust=True,
    progress=False
)

#PRICE_DATA IS ACTUALLY CLOSE PRICE DATA
if len(clean_tickers) == 1:
    # Single ticker case
    returns = data[clean_tickers[0]]['Close'].dropna()
    price_data = pd.DataFrame({
        clean_tickers[0]: returns.values
    })
else:
    # Multiple tickers case
    returns_dict = {}
    for ticker in clean_tickers:
        returns = data[ticker]['Close'].dropna()
        returns_dict[ticker] = returns.values

    price_data = pd.DataFrame(returns_dict)

print("price_data = ({")
for i, col in enumerate(price_data.columns):
    print(f"    '{col}': {price_data[col].tolist()},")
print("})")

# Also display the actual DataFrame
print("\nActual DataFrame:")
print(price_data)

mean_return = price_data.pct_change().mean()
print(mean_return)
covariance_of_return = price_data.pct_change().cov()
print(covariance_of_return)

covariance_of_close=price_data.cov()
print(covariance_of_close)

# If you have returns data, convert to price data
close_price_data = yf.download(clean_tickers, period="1y")['Close']
print(close_price_data)

pip install PyPortfolioOpt

import numpy as np
import pandas as pd
from pypfopt import (
    EfficientFrontier,
    risk_models,
    expected_returns,
    objective_functions
)

# Clean data
price_data_cleaned = price_data.dropna()

# Calculate parameters
mu = expected_returns.mean_historical_return(price_data_cleaned)
cov_matrix = risk_models.semicovariance(price_data_cleaned)  # Using proper variable name

# Initialize efficient frontier with shorting allowed
ef = EfficientFrontier(mu, cov_matrix, weight_bounds=(-1, 1))

# Add diversification objective
ef.add_objective(objective_functions.L2_reg, gamma=0.1)


try:
    weights = ef.max_sharpe()  # Corrected method name
    cleaned_weights = ef.clean_weights()

    # Print performance metrics
    ef.portfolio_performance(verbose=True)  # Corrected parentheses
    print("\nOptimal weights:", cleaned_weights)

except Exception as e:
    print(f"Optimization failed: {str(e)}")

from pypfopt.discrete_allocation import DiscreteAllocation, get_latest_prices

#SHARES TO BE ALLOCATED TO EACH TICKER
portfolio_value=float(input("ENTER THE VALUE YOU ARE LOOKING TO INVEST : "))
latest_prices = get_latest_prices(price_data_cleaned)
da = DiscreteAllocation(cleaned_weights, latest_prices, total_portfolio_value=portfolio_value)
allocation, leftover = da.lp_portfolio()
print(allocation)

def get_market_caps(tickers):
    """Get market capitalization for each ticker"""

    market_caps = {}

    for ticker in tickers:
        try:
            # Get stock info
            stock = yf.Ticker(ticker)
            info = stock.info

            # Get market cap
            market_cap = info.get('marketCap', None)
            company_name = info.get('longName', 'N/A')

            if market_cap:
                market_cap_billions = market_cap / 1e9
                market_caps[ticker] = market_cap
                print(f"{ticker}: ${market_cap_billions:.2f}B - {company_name}")
            else:
                print(f"{ticker}: Market cap not available")

        except Exception as e:
            print(f"{ticker}: Error - {e}")

    return market_caps

# Main execution
tickers = clean_tickers
market_caps = get_market_caps(tickers)

import numpy as np
import pandas as pd

def create_dynamic_bl_inputs(tickers):
    """
    Interactive function to create P matrix and Q vector for Black-Litterman model
    Allows user to input any number of views and any number of assets

    Parameters:
    - tickers: list of ticker symbols in the portfolio

    Returns:
    - P: Picking matrix (n_views x n_assets)
    - Q: Views vector (n_views x 1)
    - view_descriptions: list of view descriptions
    """

    print(f"Creating Black-Litterman views for portfolio: {tickers}")
    print(f"Number of assets: {len(tickers)}")
    print("\n" + "="*60)

    # Get number of views from user
    while True:
        try:
            n_views = int(input("\nHow many views do you want to create? "))
            if n_views > 0:
                break
            else:
                print("Please enter a positive number.")
        except ValueError:
            print("Please enter a valid integer.")

    # Initialize matrices
    n_assets = len(tickers)
    P = np.zeros((n_views, n_assets))
    Q = np.zeros(n_views)
    view_descriptions = []

    print(f"\nAsset indices for reference:")
    for i, ticker in enumerate(tickers):
        print(f"{i}: {ticker}")

    # Collect each view
    for view_idx in range(n_views):
        print(f"\n{'='*40}")
        print(f"CREATING VIEW {view_idx + 1} of {n_views}")
        print(f"{'='*40}")

        # Get view type
        while True:
            view_type = input("""
Choose view type:
1. Absolute view (single asset expected return)
2. Relative view (one asset vs another)
Enter choice (1 or 2): """).strip()

            if view_type in ['1', '2']:
                break
            else:
                print("Please enter 1 or 2")

        if view_type == '1':
            # Absolute view
            P_row, q_val, description = create_absolute_view(tickers)

        elif view_type == '2':
            # Relative view
            P_row, q_val, description = create_relative_view(tickers)


        # Store the view
        P[view_idx, :] = P_row # P_row might be a 1xN array from relative view, need to handle this.
        Q[view_idx] = q_val   # q_val might be a 1x1 array from relative view, need to handle this.
        view_descriptions.append(description) # description might be a list from relative view, need to handle this.

        # Show current view
        print(f"\nView {view_idx + 1} created:")
        print(f"Description: {description}")
        print(f"P row: {P_row}")
        print(f"Q value: {q_val:.4f}")

    return P, Q, view_descriptions

def create_absolute_view(tickers):
    """Create an absolute view for a single asset"""
    print("\n--- Absolute View ---")
    print("This creates a view on the absolute expected return of one asset")

    # Select asset
    while True:
        try:
            asset_choice = input(f"\nSelect asset (enter ticker or index 0-{len(tickers)-1}): ").strip().upper()

            if asset_choice in tickers:
                asset_idx = tickers.index(asset_choice)
                break
            elif asset_choice.isdigit() and 0 <= int(asset_choice) < len(tickers):
                asset_idx = int(asset_choice)
                break
            else:
                print(f"Please enter a valid ticker from {tickers} or index 0-{len(tickers)-1}")
        except:
            print("Invalid input. Please try again.")

    # Get expected return
    while True:
        try:
            expected_return = float(input(f"\nExpected return for {tickers[asset_idx]} (as decimal, e.g., 0.12 for 12%): "))
            break
        except ValueError:
            print("Please enter a valid number.")

    # Create P row (all zeros except 1 for selected asset)
    P_row = np.zeros(len(tickers))
    P_row[asset_idx] = 1.0

    description = f"{tickers[asset_idx]} expected return: {expected_return:.2%}"

    return P_row, expected_return, description

def create_relative_view(tickers):
    """Create one or more relative views between assets"""
    print("\n--- Relative View ---")
    print("This creates views where one asset will outperform another")

    # Get number of views
    while True:
        try:
            # Changed variable name to reflect number of *relative* views to create
            n_relative_views = int(input("\nHow many relative views do you want to create? "))
            if n_relative_views > 0:
                break
            print("Please enter a positive number.")
        except ValueError:
            print("Please enter a valid integer.")

    # Changed initialisation to lists to store multiple views
    P_rows = []
    outperformance_values = []
    descriptions = []

    for i in range(n_relative_views): # Iterate based on the number of relative views
        print(f"\nCreating relative view {i+1}/{n_relative_views}")

        # Select long asset
        while True:
            long_choice = input("Select LONG asset (expected to outperform): ").strip().upper()
            if long_choice in tickers:
                long_idx = tickers.index(long_choice)
                break
            if long_choice.isdigit() and 0 <= int(long_choice) < len(tickers):
                long_idx = int(long_choice)
                break
            print(f"Please enter a valid ticker from {tickers}")

        # Select short asset
        while True:
            short_choice = input("Select SHORT asset (expected to underperform): ").strip().upper()
            if short_choice in tickers:
                short_idx = tickers.index(short_choice)
                if short_idx != long_idx:
                    break
                print("Short asset must be different from long asset.")
            elif short_choice.isdigit() and 0 <= int(short_choice) < len(tickers):
                short_idx = int(short_choice)
                if short_idx != long_idx:
                    break
                print("Short asset must be different from long asset.")
            else:
                print(f"Please enter a valid ticker from {tickers}")

        # Get outperformance
        while True:
            try:
                outperformance = float(input(
                    f"Expected outperformance of {tickers[long_idx]} vs {tickers[short_idx]} (as decimal): "))
                break
            except ValueError:
                print("Please enter a valid number.")

        # Create P row for this relative view
        P_row = np.zeros(len(tickers))
        P_row[long_idx] = 1.0/n_relative_views
        P_row[short_idx] = -1.0/n_relative_views

        # Append the created P_row, outperformance, and description for THIS relative view
        P_rows.append(P_row)
        outperformance_values.append(outperformance)
        descriptions.append(
            f"{tickers[long_idx]} vs {tickers[short_idx]} outperformance: {outperformance:.2%}"
        )

    return P_row, outperformance, descriptions



    # Return the combined matrix, vector, and list of descriptions
    # NOTE: The create_dynamic_bl_inputs function expects a single P_row, q_val, and description
    # This requires a change in how create_dynamic_bl_inputs handles the output of create_relative_view
    # The current structure of create_dynamic_bl_inputs assumes create_relative_view returns a single view.
    # We need to decide if create_relative_view should create multiple rows for one call, or if create_dynamic_bl_inputs
    # should handle multiple calls to create_relative_view for a single view type selection.
    # Based on the original structure (returning P_row, q_val, description), it seems the intent
    # was to create one relative view per loop iteration in create_dynamic_bl_inputs.
    # Let's revise create_relative_view to create just ONE relative view per call.

    # REVISED create_relative_view to create only ONE relative view per call
    print("\n--- Relative View ---")
    print("This creates a single view where one asset will outperform another")


def display_bl_inputs(P, Q, view_descriptions, tickers):
    """Display the final P matrix and Q vector in a nice format"""
    print("\n" + "="*80)
    print("BLACK-LITTERMAN INPUTS CREATED")
    print("="*80)

    print(f"\nNumber of views: {len(Q)}")
    print(f"Number of assets: {len(tickers)}")

    # Display P matrix
    print(f"\nPICKING MATRIX (P):")
    print(f"Shape: {P.shape}")
    P_df = pd.DataFrame(P,
                       columns=tickers,
                       index=[f"View_{i+1}" for i in range(len(Q))])
    print(P_df.round(4))


    # Display Q vector
    print(f"\nVIEWS VECTOR (Q):")
    Q_df = pd.DataFrame({
        # 'View': [f"View_{i+1}" for i in range(len(Q))],
        # 'Description': view_descriptions,
        'Expected_Return': Q,
        'Expected_Return_%': Q*100,
    })
    print(Q_df)

    # Summary statistics
    print(f"\nSUMMARY:")
    print(f"Q vector mean: {np.mean(Q):.4f}")
    print(f"Q vector std: {np.std(Q):.4f}")
    print(f"P matrix L1 norms: {np.sum(np.abs(P), axis=1)}")

    return P_df, Q_df

# Main execution function
def main_bl_input_creation(tickers):

    if not isinstance(tickers, list) or len(tickers) == 0:
        raise ValueError("Please provide a non-empty list of tickers")

    print("BLACK-LITTERMAN INPUT GENERATOR")
    print("="*50)

    # Create inputs
    P, Q, descriptions = create_dynamic_bl_inputs(tickers)

    # Display results
    P_df, Q_df = display_bl_inputs(P, Q, descriptions, tickers)

    return P, Q, descriptions, P_df, Q_df


if __name__ == "__main__":

    sample_tickers = clean_tickers
    P, Q, descriptions, P_df, Q_df = main_bl_input_creation(sample_tickers)

P_df=np.array(P_df)
print(P_df)
Q_df=np.array(Q_df)
print(Q_df)

import yfinance as yf
import pandas as pd


market_prices = yf.download("SPY", period="max", auto_adjust=False)["Adj Close"]

# Display the head of the DataFrame to verify
print(market_prices.head())

import pypfopt
pypfopt.__version__

from pypfopt import black_litterman, risk_models
from pypfopt import BlackLittermanModel, plotting

# Replace 'prices' with the defined variable 'price_data'

delta = black_litterman.market_implied_risk_aversion(market_prices)
delta

print(delta)

from pypfopt.efficient_frontier import EfficientFrontier

from pypfopt import black_litterman, risk_models



prior = black_litterman.market_implied_prior_returns(market_caps, delta, covariance_of_return)

prior=np.array(prior)
print(prior)

viewdict = {}
n = len(clean_tickers)
#viewdict is the expected returns which we are expecting

for ticker in clean_tickers:
    viewdict[ticker] = float(input(f"Expected return of {ticker} in decimals: "))

print(viewdict)

bl = BlackLittermanModel(
    cov_matrix=covariance_of_return,
    absolute_views=viewdict,
    pi=prior
)

rets = bl.bl_returns()
ef = EfficientFrontier(rets, cov_matrix)
bl.bl_weights(delta)
weights = bl.clean_weights()

print(weights)